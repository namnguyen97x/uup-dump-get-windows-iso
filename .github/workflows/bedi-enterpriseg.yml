name: bedi-enterpriseg
on:
  workflow_dispatch:
    inputs:
      artifact_name:
        description: 'Artifact name from build workflow (e.g. windows-11, windows-10, windows-server-2025) - leave empty to use latest'
        required: false
        default: ''
      build:
        description: 'Build number folder to create/use (e.g. 22621) - used for Bedi folder structure'
        required: true
        default: '22621'
      wim_index:
        description: 'WIM/ESD image index to use (1 for typical single-index images)'
        required: true
        default: '1'
      run_id:
        description: 'Run ID of build workflow to download artifact from (leave empty for auto-detect)'
        required: false
        default: ''
  workflow_run:
    workflows: ["build"]
    types: [completed]
    branches: [main, master]

jobs:
  bedi-enterpriseg:
    runs-on: windows-2022
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') }}
    env:
      ROOT: ${{ github.workspace }}\Bedi
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Determine artifact name and build number
        id: artifact-info
        shell: pwsh
        run: |
          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            $artifactName = "${{ github.event.inputs.artifact_name }}"
            if ([string]::IsNullOrEmpty($artifactName)) {
              $artifactName = "windows-11"  # Default to windows-11
            }
            $buildNumber = "${{ github.event.inputs.build }}"
          } else {
            # For workflow_run trigger, try to find available artifacts
            Write-Host "Attempting to find available artifacts..."
            
            # Try Windows version artifacts (actual artifact names from build.yml)
            $possibleArtifacts = @("windows-11", "windows-10", "windows-server-2025")
            $artifactName = $null
            
            foreach ($artifact in $possibleArtifacts) {
              Write-Host "Checking if artifact '$artifact' exists..."
              try {
                # Use GitHub API to check if artifact exists
                $headers = @{
                  'Authorization' = "Bearer ${{ secrets.GITHUB_TOKEN }}"
                  'Accept' = 'application/vnd.github+json'
                }
                $response = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/actions/artifacts" -Headers $headers
                
                $foundArtifact = $response.artifacts | Where-Object { $_.name -eq $artifact -and $_.expired -eq $false } | Select-Object -First 1
                if ($foundArtifact) {
                  $artifactName = $artifact
                  Write-Host "Found available artifact: $artifact"
                  break
                }
              } catch {
                Write-Host "Error checking artifact '$artifact': $($_.Exception.Message)"
              }
            }
            
            if (-not $artifactName) {
              Write-Warning "No available artifacts found. Using default: windows-11"
              $artifactName = "windows-11"
            }
            
            # Auto-detect build number from artifact name based on uup-dump-get-windows-iso.ps1
            $buildNumber = switch ($artifactName) {
              "windows-11" { "22621" }      # Windows 11 22H2 (22621) - EnterpriseG supported
              "windows-10" { "19044" }      # Windows 10 21H2 (19044)
              "windows-server-2025" { "26100" }  # Windows Server 2025 (26100)
              default { "22621" }
            }
            Write-Host "Auto-detected build number: $buildNumber for artifact: $artifactName"
          }
          
          Write-Output "name=$artifactName" >> $env:GITHUB_OUTPUT
          Write-Output "build=$buildNumber" >> $env:GITHUB_OUTPUT
          Write-Host "Using artifact name: $artifactName"
          Write-Host "Using build number: $buildNumber"

      - name: List available artifacts (debug)
        shell: pwsh
        run: |
          Write-Host "Listing all available artifacts..."
          try {
            $headers = @{
              'Authorization' = "Bearer ${{ secrets.GITHUB_TOKEN }}"
              'Accept' = 'application/vnd.github+json'
            }
            $response = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/actions/artifacts" -Headers $headers
            
            Write-Host "Total artifacts found: $($response.artifacts.Count)"
            foreach ($artifact in $response.artifacts) {
              $status = if ($artifact.expired) { "EXPIRED" } else { "AVAILABLE" }
              Write-Host "  - $($artifact.name) ($status) - Created: $($artifact.created_at)"
            }
          } catch {
            Write-Warning "Could not list artifacts: $($_.Exception.Message)"
          }

      - name: Debug workflow run info
        shell: pwsh
        run: |
          Write-Host "Workflow run debug info:"
          Write-Host "  Event name: ${{ github.event_name }}"
          Write-Host "  Current run ID: ${{ github.run_id }}"
          if ("${{ github.event_name }}" -eq "workflow_run") {
            Write-Host "  Triggering workflow run ID: ${{ github.event.workflow_run.id }}"
            Write-Host "  Triggering workflow name: ${{ github.event.workflow_run.name }}"
            Write-Host "  Triggering workflow conclusion: ${{ github.event.workflow_run.conclusion }}"
          }

      - name: Find latest build workflow run
        id: find-run
        shell: pwsh
        run: |
          if ("${{ github.event_name }}" -eq "workflow_dispatch" -and [string]::IsNullOrEmpty("${{ github.event.inputs.run_id }}")) {
            Write-Host "Finding latest successful build workflow run..."
            try {
              $headers = @{
                'Authorization' = "Bearer ${{ secrets.GITHUB_TOKEN }}"
                'Accept' = 'application/vnd.github+json'
              }
              
              # Get the latest successful build run
              $response = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/actions/workflows/build.yml/runs?status=success&per_page=5" -Headers $headers
              
              if ($response.workflow_runs.Count -gt 0) {
                $latestRun = $response.workflow_runs[0]
                Write-Output "run_id=$($latestRun.id)" >> $env:GITHUB_OUTPUT
                Write-Host "Using latest build run: $($latestRun.id) - $($latestRun.head_commit.message)"
              } else {
                Write-Warning "No successful build runs found"
                Write-Output "run_id=" >> $env:GITHUB_OUTPUT
              }
            } catch {
              Write-Warning "Could not find build runs: $($_.Exception.Message)"
              Write-Output "run_id=" >> $env:GITHUB_OUTPUT
            }
          } else {
            Write-Output "run_id=${{ github.event.inputs.run_id }}" >> $env:GITHUB_OUTPUT
          }

      - name: Check artifacts in specific run
        shell: pwsh
        run: |
          $runId = "${{ steps.find-run.outputs.run_id }}"
          if (-not [string]::IsNullOrEmpty($runId)) {
            Write-Host "Checking artifacts in run: $runId"
            try {
              $headers = @{
                'Authorization' = "Bearer ${{ secrets.GITHUB_TOKEN }}"
                'Accept' = 'application/vnd.github+json'
              }
              $response = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/actions/runs/$runId/artifacts" -Headers $headers
              
              Write-Host "Artifacts in run $runId :"
              foreach ($artifact in $response.artifacts) {
                $status = if ($artifact.expired) { "EXPIRED" } else { "AVAILABLE" }
                Write-Host "  - $($artifact.name) ($status) - Size: $($artifact.size_in_bytes) bytes"
              }
            } catch {
              Write-Warning "Could not check artifacts in run $runId : $($_.Exception.Message)"
            }
          }

      - name: Download artifact using GitHub API
        shell: pwsh
        run: |
          $artifactName = "${{ steps.artifact-info.outputs.name }}"
          $runId = "${{ github.event_name == 'workflow_run' && github.event.workflow_run.id || steps.find-run.outputs.run_id }}"
          
          Write-Host "Downloading artifact '$artifactName' from run '$runId'"
          
          # Create artifacts directory
          if (-not (Test-Path -Path "artifacts")) {
            New-Item -ItemType Directory -Path "artifacts" | Out-Null
          }
          
          try {
            $headers = @{
              'Authorization' = "Bearer ${{ secrets.GITHUB_TOKEN }}"
              'Accept' = 'application/vnd.github+json'
            }
            
            # Get artifact download URL
            $response = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/actions/runs/$runId/artifacts" -Headers $headers
            $artifact = $response.artifacts | Where-Object { $_.name -eq $artifactName -and -not $_.expired }
            
            if ($artifact) {
              Write-Host "Found artifact: $($artifact.name) (Size: $($artifact.size_in_bytes) bytes)"
              
              # Get download URL - use the artifact's archive_download_url
              $downloadUrl = $artifact.archive_download_url
              
              if ($downloadUrl) {
                Write-Host "Downloading from: $downloadUrl"
                
                # Use curl with proper authentication
                $env:GITHUB_TOKEN = "${{ secrets.GITHUB_TOKEN }}"
                curl -L -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" -H "Accept: application/vnd.github+json" -o "artifacts\$artifactName.zip" $downloadUrl
                
                if ($LASTEXITCODE -eq 0) {
                  Write-Host "Download completed successfully"
                  
                  # Extract the zip file
                  Expand-Archive -Path "artifacts\$artifactName.zip" -DestinationPath "artifacts" -Force
                  Write-Host "Extraction completed"
                } else {
                  Write-Error "Download failed with curl"
                  exit 1
                }
              } else {
                Write-Error "Could not get download URL for artifact"
                exit 1
              }
            } else {
              Write-Error "Artifact '$artifactName' not found in run '$runId' or expired"
              exit 1
            }
          } catch {
            Write-Error "Failed to download artifact: $($_.Exception.Message)"
            exit 1
          }

      - name: Prepare ISO for Bedi
        shell: pwsh
        run: |
          # Find the ISO file recursively in artifacts (may be in subdirectory)
          $isoFile = Get-ChildItem -Path "artifacts" -Filter "*.iso" -Recurse | Select-Object -First 1
          if (-not $isoFile) {
            Write-Error "No ISO file found in artifacts. Check artifact name: ${{ steps.artifact-info.outputs.name }}"
            Write-Host "Contents of artifacts directory:"
            Get-ChildItem -Path "artifacts" -Recurse | ForEach-Object { Write-Host "  $($_.FullName)" }
            exit 1
          }
          
          Write-Host "Found ISO file: $($isoFile.FullName)"
          Write-Host "ISO size: $([math]::Round($isoFile.Length / 1GB, 2)) GB"
          
          # Pre-validate ISO structure before copying
          Write-Host "Pre-validating ISO structure..."
          $img = Mount-DiskImage $isoFile.FullName -PassThru
          try {
            $vol = $img | Get-Volume
            $root = "$($vol.DriveLetter):\"
            Write-Host "ISO mounted at: $root"
            
            # Check for sources folder
            $sourcesPath = Join-Path $root 'sources'
            if (-not (Test-Path $sourcesPath)) {
              Write-Error "Invalid ISO: missing 'sources' folder"
              Write-Host "Root directory contents:"
              Get-ChildItem $root | ForEach-Object { Write-Host "  $($_.Name)" }
              exit 1
            }
            
            # Check for install files
            $installWim = Join-Path $sourcesPath 'install.wim'
            $installEsd = Join-Path $sourcesPath 'install.esd'
            if (-not (Test-Path $installWim) -and -not (Test-Path $installEsd)) {
              Write-Error "Invalid ISO: missing install.wim/esd in 'sources'"
              Write-Host "Sources directory contents:"
              Get-ChildItem $sourcesPath | ForEach-Object { Write-Host "  $($_.Name)" }
              exit 1
            }
            
            Write-Host "ISO validation passed - contains valid Windows installation files"
          } finally {
            Dismount-DiskImage -ImagePath $isoFile.FullName | Out-Null
          }
          
          # Ensure Bedi directory exists
          if (-not (Test-Path -Path "${{ github.workspace }}\Bedi")) {
            New-Item -ItemType Directory -Path "${{ github.workspace }}\Bedi" | Out-Null
          }
          if (-not (Test-Path -Path "${{ github.workspace }}\Bedi\Files")) {
            New-Item -ItemType Directory -Path "${{ github.workspace }}\Bedi\Files" | Out-Null
          }
          
          # Copy ISO to Bedi directory for processing
          $targetIso = Join-Path "${{ github.workspace }}\Bedi" "uup.iso"
          Copy-Item -Path $isoFile.FullName -Destination $targetIso -Force
          Write-Host "ISO copied to: $targetIso"
          
          # Show artifact info
          $jsonFile = Get-ChildItem -Path "artifacts" -Filter "*.json" -Recurse | Select-Object -First 1
          if ($jsonFile) {
            $buildInfo = Get-Content $jsonFile.FullName | ConvertFrom-Json
            Write-Host "Build Info:"
            Write-Host "  Name: $($buildInfo.name)"
            Write-Host "  Build: $($buildInfo.build)"
            Write-Host "  Title: $($buildInfo.title)"
          }

      - name: Ensure Bedi Files folder exists
        shell: pwsh
        run: |
          if (-not (Test-Path -Path "${{ github.workspace }}\Bedi")) {
            New-Item -ItemType Directory -Path "${{ github.workspace }}\Bedi" | Out-Null
          }
          if (-not (Test-Path -Path "${{ github.workspace }}\Bedi\Files")) {
            New-Item -ItemType Directory -Path "${{ github.workspace }}\Bedi\Files" | Out-Null
          }

      - name: Install 7zip CLI (for ESD extraction)
        shell: pwsh
        run: |
          choco install 7zip.commandline --no-progress -y
          if ($LASTEXITCODE -ne 0) { Write-Error "Failed to install 7zip.commandline"; exit 1 }
          if (-not (Get-Command 7z.exe -ErrorAction SilentlyContinue)) { Write-Error "7z.exe not found after install"; exit 1 }

      - name: Optional - Download EnterpriseG payload artifact (clients.esd / EditionSpecific / LP)
        shell: pwsh
        run: |
          $buildNumber = "${{ steps.artifact-info.outputs.build }}"
          $payloadNames = @("payload-$buildNumber","enterpriseg-payload-$buildNumber","payload-enterpriseg-$buildNumber")
          $headers = @{ 'Authorization' = "Bearer ${{ secrets.GITHUB_TOKEN }}"; 'Accept' = 'application/vnd.github+json' }
          $found = $null
          try {
            $resp = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/actions/artifacts" -Headers $headers
            foreach ($n in $payloadNames) {
              $a = $resp.artifacts | Where-Object { $_.name -eq $n -and -not $_.expired } | Select-Object -First 1
              if ($a) { $found = $a; break }
            }
          } catch { Write-Host "Could not query artifacts: $($_.Exception.Message)" }

          if ($null -ne $found) {
            Write-Host "Found payload artifact: $($found.name)"
            $dl = $found.archive_download_url
            if (-not (Test-Path 'artifacts')) { New-Item -ItemType Directory artifacts | Out-Null }
            curl -L -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" -H "Accept: application/vnd.github+json" -o "artifacts\$($found.name).zip" $dl
            Expand-Archive -Path "artifacts\$($found.name).zip" -DestinationPath "artifacts\$($found.name)" -Force
            $target = Join-Path "${{ github.workspace }}\Bedi" $buildNumber
            if (-not (Test-Path $target)) { New-Item -ItemType Directory -Path $target | Out-Null }
            Get-ChildItem -Path "artifacts\$($found.name)" -Recurse -Include "clients.esd","Microsoft-Windows-EditionSpecific-EnterpriseG-Package.esd","Microsoft-Windows-Client-LanguagePack-Package-amd64-en-us.esd" | ForEach-Object {
              Copy-Item $_.FullName -Destination $target -Force
            }
          } else {
            Write-Host "No payload artifact found. Proceeding; bedi_auto will fail if payloads are missing."
          }

      - name: Install Windows ADK Deployment Tools (oscdimg)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
          $adkUrl = 'https://download.microsoft.com/download/2/d/9/2d9c8902-3fcd-48a6-a22a-432b08bed61e/ADK/adksetup.exe'  # Windows ADK Web Installer (direct)
          $adkPath = Join-Path $env:TEMP 'adksetup.exe'
          
          function Download-With-Retry($url, $dest, $retries = 3) {
            for ($i=1; $i -le $retries; $i++) {
              try {
                if (Test-Path $dest) { Remove-Item $dest -Force -ErrorAction SilentlyContinue }
                Write-Host "Attempt ${i}: downloading ${url} ..."
                Invoke-WebRequest -Uri $url -OutFile $dest -UseBasicParsing
                if ((Test-Path $dest) -and ((Get-Item $dest).Length -gt 1000000)) { return $true }
                Write-Host "Downloaded file too small, retrying..."
              } catch {
                Write-Host "Download failed: $($_.Exception.Message)"
              }
              Start-Sleep -Seconds 3
            }
            return $false
          }

          if (-not (Download-With-Retry $adkUrl $adkPath 4)) { Write-Error "Failed to download ADK setup after retries" }

          Write-Host "Installing ADK Deployment Tools (silent)..."
          $args = '/quiet /norestart /features OptionId.DeploymentTools'
          $proc = Start-Process -FilePath $adkPath -ArgumentList $args -WorkingDirectory $env:TEMP -PassThru -Wait
          if ($proc.ExitCode -ne 0) { Write-Error "ADK setup exited with code $($proc.ExitCode)" }

          Write-Host "Verifying oscdimg.exe installation..."
          $cand = @(
            (Get-Command oscdimg.exe -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source -ErrorAction SilentlyContinue),
            'C:\\Program Files (x86)\\Windows Kits\\11\\Assessment and Deployment Kit\\Deployment Tools\\amd64\\Oscdimg\\oscdimg.exe',
            'C:\\Program Files (x86)\\Windows Kits\\10\\Assessment and Deployment Kit\\Deployment Tools\\amd64\\Oscdimg\\oscdimg.exe'
          ) | Where-Object { $_ -and (Test-Path $_) } | Select-Object -First 1

          if (-not $cand) { Write-Error "oscdimg.exe not found after ADK install"; exit 1 }
          Write-Host "oscdimg: $cand"

      - name: Validate runner prerequisites
        shell: pwsh
        run: |
          Write-Host "Checking DISM availability"
          if (-not (Get-Command dism.exe -ErrorAction SilentlyContinue)) {
            Write-Error "dism.exe not found in PATH. The runner must be a Windows machine with DISM available."
            exit 1
          }
          Write-Host "Checking PowerShell version"
          if ($PSVersionTable.PSVersion.Major -lt 5) {
            Write-Error "PowerShell 5+ required on the runner."
            exit 1
          }

      - name: Validate EnterpriseG requirements
        shell: pwsh
        run: |
          Write-Host "Validating EnterpriseG requirements..."
          
          # Check if build number is supported for EnterpriseG
          $supportedBuilds = @("17763", "19041", "22000", "22621", "25398", "26100", "27729")
          $buildNumber = "${{ steps.artifact-info.outputs.build }}"
          
          if ($buildNumber -notin $supportedBuilds) {
            Write-Error "EnterpriseG only supports builds: $($supportedBuilds -join ', '). Current build: $buildNumber"
            exit 1
          }
          
          Write-Host "Build $buildNumber is supported for EnterpriseG"
          
          # EnterpriseG specific settings
          Write-Host "EnterpriseG settings:"
          Write-Host "  - Language: en-US only"
          Write-Host "  - Microsoft Edge: Without (removed)"
          Write-Host "  - Windows Defender: Without (removed)"
          Write-Host "  - Product Key: YYVX9-NTFWV-6MDM3-9PT4T-4M68B"
          
          # Verify ISO file exists
          $isoPath = "${{ github.workspace }}\Bedi\uup.iso"
          if (-not (Test-Path $isoPath)) {
            Write-Error "ISO file not found: $isoPath"
            exit 1
          }
          
          $isoInfo = Get-Item $isoPath
          Write-Host "ISO file verified: $($isoInfo.FullName)"
          Write-Host "ISO file size: $([math]::Round($isoInfo.Length / 1GB, 2)) GB"

      - name: Run Bedi CI wrapper
        shell: pwsh
        run: |
          $script = Join-Path ${{ github.workspace }} 'Bedi\Bedi_bedi-ci-wrapper_Version3.ps1'
          if (-not (Test-Path $script)) {
            Write-Error "Wrapper script not found: $script. Ensure Bedi/Bedi_bedi-ci-wrapper_Version3.ps1 exists in the repo."
            exit 1
          }
          & powershell -ExecutionPolicy Bypass -NoProfile -File $script -IsoPath "${{ github.workspace }}\Bedi\uup.iso" -Build "${{ steps.artifact-info.outputs.build }}" -WimIndex "${{ github.event.inputs.wim_index }}" -TargetSKU "EnterpriseG"

      - name: Upload build artifacts (WIM/ESD/logs)
        uses: actions/upload-artifact@v4
        with:
          name: bedi-output-${{ steps.artifact-info.outputs.build }}
          path: |
            Bedi\bedi-output-${{ steps.artifact-info.outputs.build }}\*.iso
            Bedi\log*
            Bedi\*.log